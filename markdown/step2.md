# 2단계 인수조건
## Feature: 지하철 노선 관련 기능
    Scenario: 지하철 노선을 생성한다.
    Given 상행선, 하행선이 등록되어있다.
    When 지하철 노선을 생성 요청한다.
    Then 지하철 노선이 생성된다.
<hr/>

    Scenario: 기존에 존재하는 지하철 노선 이름으로 지하철 노선을 생성한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 지하철 노선을 생성 요청한다.
    Then 지하철 노선 생성이 실패된다.
<hr/>

    Scenario: 지하철 노선 목록을 조회한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 지하철 노선 목록 조회 요청한다.
    Then 지하철 노선 목록을 포함한 응답을 반환한다.
         지하철 노선은 구간정보를 포함하고 있다.
<hr/>

    Scenario: 지하철 노선을 조회한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 지하철 노선 조회 요청한다.
    Then 지하철 노선을 포함한 응답을 반환한다.
         지하철 노선은 구간정보를 포함하고 있다.
<hr/>

    Scenario: 지하철 노선을 수정한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 지하철 노선 수정 요청한다.
    Then 지하철 노선이 수정된다.
<hr/>

    Scenario: 존재하지 않는 지하철 노선을 수정한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 존재하지않는 지하철 노선 수정 요청한다.
    Then 지하철 노선이 수정이 실패한다.
<hr/>

    Scenario: 지하철 노선을 삭제한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 지하철 노선 삭제 요청한다.
    Then 지하철 노선이 삭제된다.
<hr/>

    Scenario: 존재하지 않는 지하철 노선을 삭제한다.
    Given 상행선,하행선을 포함한 지하철 노선이 등록되어 있다
    When 존재하지않는 지하철 노선 삭제 요청한다.
    Then 지하철 노선이 삭제가 실패한다.

# 요구사항
- [x] 노선 생성 시 종점역(상행, 하행) 정보를 요청 파라미터에 함께 추가하기
    - [x] 두 종점역은 구간의 형태로 관리되어야 함
- [x] 노선 조회 시 응답 결과에 역 목록 추가하기
    - [x] 상행역 부터 하행역 순으로 정렬되어야 함
    
# 요구사항 설명
노선 생성 시 두 종점역 추가하기
- 인수 테스트와 DTO 등 수정이 필요함

노선 객체에서 구간 정보를 관리하기
- 노선 생성시 전달되는 두 종점역은 노선의 상태로 관리되는 것이 아니라 구간으로 관리되어야 함

노선의 역 목록을 조회하는 기능 구현하기
- 노선 조회 시 역 목록을 함께 응답할 수 있도록 변경
- 노선에 등록된 구간을 순서대로 정렬하여 상행 종점부터 하행 종점까지 목록을 응답하기
- 필요시 노선과 구간(혹은 역)의 관계를 새로 맺기

# 힌트
기능 변경 시 인수 테스트를 먼저 변경하기
- 기능(혹은 스펙) 변경 시 테스트가 있는 환경에서 프로덕션 코드를 먼저 수정할 경우 어려움을 겪을 수 있음
    - 프로덕션 코드를 수정하고 그에 맞춰 테스트 코드를 수정해 주어야 해서 두번 작업하는 느낌
- 항상 테스트를 먼저 수정한 다음 프로덕션을 수정하자!
- 더 좋은 방법은 기존 테스트는 두고 새로운 테스트를 먼저 만들고 시작하자!

# 피드백
- private 메서드에 @Transactional 어노테이션을 적용하면 ??
  
      스프링 트랜잭션의 기본 모드인 proxy 모드에서는 오직 외부로부터의 method 호출이 발생한 경우에만 
      method가 인터셉트 되어 트랜잭션 관리가 적용된다. 
      즉, 다시 말해서 오브젝트 내의 한 method가 동일 오브젝트 내의 다른 method를 호출할 경우에는 
      피 호출 method에 @Transactional 어노테이션이 명시되어 있더라도 실행시 트랜잭션이 스프링에 의해 관리되지 않는다.

      AOP, Transactional, Proxy 다시 공부하기

- 생성자 안에서는 필드할당만
  - 단일책임원칙 위반
  - 직접 테스트가 어려움
  - 이음매를 지운다
  - 협업 객체를 강요한다
  
[출처]https://battleshippark.wordpress.com/2018/05/29/%EA%B2%B0%ED%95%A8-%EC%83%9D%EC%84%B1%EC%9E%90%EA%B0%80-%EC%8B%A4%EC%A0%9C-%EC%9E%91%EC%97%85%EC%9D%84-%EC%88%98%ED%96%89%ED%95%A9%EB%8B%88%EB%8B%A4/
